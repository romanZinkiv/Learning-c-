// 180. Capturing a context with a lambda. Lambda or Anonymous functions.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
using namespace std;

//ЛЯМБДА/АНОНІМНА ФУНКЦІЯ - ЦЕ ФУНКЦІЯ, ПОКИ МИ ЇЇ НЕ ВИКЛИЧЕМО - ВОНА НЕ СПРАЦЮЄ (не працюватиме)

class MyClass
{
public:
	int a = 11;
	void msg()
	{
		cout << "msg" << endl;
	}
	void Lambda()
	{
		//захоплюємо в контекст весь клас (чи об"єкт ? )
		auto f = [this] {
			this->msg();
		};
		f();
	}
};

int main()
{

	int a = 55;
	int b = 10;

	//в контекст лямбда функції [] можна захопити лише дані, що знаходяться вище неї
	//при передачі в контекст по значенню ми можемо читати ті дані, але не змінювати 
	//для того щоб мати можливість і зчитувати, і змінювати дані, нам необхідно захоплювати контекст по силці

	// [=] - захоплюємо всі змінні (за значенням), що знаходяться за межами контексту лямбда/анонімної функції
	// (що знаходяться вище лямбда функції)
	//auto f = [=]()
	// [&] - захоплюємо всі змінні контексту по силці (&) (що знаходяться вище лямбда функції)
	//auto f = [&]()
	//справжня передача за значенням: створюється локальна копія, можемо її не лише читати, а й змінювати,
	// ці зміни ніяк не позначаться на контекстних змінних
	//auto f = [=]()mutable
	//так теж працюватиме, але лише для змінних a та b
	//auto f = [a, b]()mutable
	// все що робитиметься з змінною a всередині лямбди позначиться на ній (змінній за межами контексту лямбди),
	// змінна b працюватиме так, ніби ми передали її за значенням
	//auto f = [&a, b]()mutable
	//auto f = [a, &b]()
	//{
	//	cout << a << endl;
	//	//a = 1313;
	//	cout << b << endl;
	//	b = 1;
	//};
	//f();

	MyClass m;
	m.Lambda();

	//у такий спосіб можна вказати тип повертаємого значення (тип повернення,  значення, що повертається)
	//auto af = []()->int {};
	auto af = []()->float
	{
		return 111;
	};
	//у такої анонімної функції повернеться все рівно float, тобто 111.0, а не 111
	auto result = af();
	cout << af() << endl;

	return 0;
}