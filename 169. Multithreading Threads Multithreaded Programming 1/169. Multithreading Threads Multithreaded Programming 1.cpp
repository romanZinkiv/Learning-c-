#include <iostream>
//для роботи з потоками #include <thread>
#include <thread>
//#include <chrono> - для роботи з часом
#include <chrono>

using namespace std;


void DoWork()
{
	for (size_t i = 0; i < 10; i++)
	{
		cout << "thread ID = " << this_thread::get_id() << "\tDoWork\t" << i << endl;
		this_thread::sleep_for(chrono::milliseconds(200));
	}
}

int main()
{

	////метод this_thread::get_id() - для того щоб дізнатись ідентифікатор потоку
	////кожен раз (майже завжди) ідентифікатор потоку різний
	//cout<< this_thread::get_id() << endl;
	////метод this_thread::sleep_for(arg) призупиняє роботу потоку на певний час (arg) 
	//this_thread::sleep_for(chrono::milliseconds(3000));

	//thread - клас, що відповідає за потік, може приймати в параметрах вказівник на функцію(назва ф-ї без () )
	//thread th(DoWork);
	//але ще потрібно задати характер поведінки потоку
	//метод detach() -  робота потоку обірветься (закінчиться) в момент виходу 
	//головного потоку (в якому виконується ф-я main) //(відпускає потік в вільне плавання)
	//th.detach();
	//метод join() дозволяє дочекатись виконання тієї задачі, яка була поставлена в потоці,
	//до якого був використаний метод join
	//але метод join слід використовувати в тому місці коду, де потрібен результат роботи цього потоку
	//якщо створити поток, передавши в нього ф-ю і в наступному рядку використати метод join
	//thread th(DoWork);
	//th.join();
	//то ми отримаємо практично те саме, якби робили це все в одному потоці. 
	//задачі будуть виконуватись в різних потоках, але все рівно вони виконуватимуться послідовно 

	//робота основного потоку не блокується і працюватиме до виклику методу join()
	//коли робота доходить до метода join(), то основний потік блокується і очікує закінчення роботи
	// потоку у якого був викликаний метод join()
	
	//при роботі з потоком, для потоку необхідно викликати один з методів: join чи detach
	//інакше буде помилка
	//інакше в момент виходу із функції main(в даному випадку) чи з області видимості якоїсь іншої функції
	//де ми створюємо об"єкт thread у об"єкта класу thread буде викликано деструктор ~thread 
	//і програма спробує закритись із іншого потоку і ми отримаємо помилку тому що у неї це не вдасться

	thread th(DoWork);
	thread th2(DoWork);

	//DoWork();
	for (size_t i = 0; i < 10; i++)
	{
		cout << "thread ID = " << this_thread::get_id() << "\tmain\t" << i << endl;
		this_thread::sleep_for(chrono::milliseconds(100));
		//this_thread::sleep_for(0.1s);		//так теж можна
	}


	//робота основного потоку не блокується і працюватиме до виклику методу join()
	//коли робота доходить до методу join(), то основний потік блокується і очікує закінчення роботи
	// потоку у якого був викликаний метод join()
	//ось тут можна викликати метод join (підходяще місце)
	th.join();
	th2.join();

	return 0;
}