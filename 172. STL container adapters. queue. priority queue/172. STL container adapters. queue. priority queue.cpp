#include <iostream>
#include <vector>
#include <list>
#include <deque>

#include <queue>

using namespace std;


int main()
{
	//за замовчуванням черга є обгорткою для deque, тобто містить в собі в якості основи контейнер deque
	//vector не може бути основою черги (queue) UPD. здається може
	queue<int> q;
	//queue<int, vector<int>> q1;
	//метод back() надає доступ до останнього елемента черги (можна подивитись і змінити, але вилучити не можна)
	// q.back();
	// методи emplace i push додають елемент в кінець черги
	//
	//метод empty() перевіряє чи є пустим контейнер (якщо пустий - true, інакше false)
	//
	//метод front() дозволяє отримати доступ до першого елемента черги (подивитись і змінити(бо елемент по силці))
	//
	//метод pop() вилучає елемент з черги за принципом черги: найперший елемен черги буде вилучений
	//
	//метод size() повертає кількість елементів в черзі
	//
	//метод swap() призначений для обміну вмісту одного адаптера(контейнера) з іншим таким же адаптером
	//
	//метод _Get_container - повертає в сирому вигляді саме той контейнер, який лежить в основі нашого адаптера
	//

	q.push(56);
	q.push(4);
	q.push(7);
	q.push(99);

	cout << "queue :" << endl;
	cout << "elements count " << q.size() << endl;
	while (!q.empty())
	{
		cout << q.front() << endl;
		q.pop();
		cout << "elements count " << q.size() << endl;
	}
	cout << "elements count " << q.size() << endl;


	//за замовчуванням черга є обгорткою для deque, тобто містить в собі в якості основи контейнер deque
	//list не може бути основою черги з пріорітетом (queue) UPD. здається може
	priority_queue<int> pq;
	pq.push(56);
	pq.push(4);
	pq.push(7);
	pq.push(99);
	//priority_queue<int, vector<int>> pq2;
	//
	//методи emplace i push
	//
	//метод empty
	//
	//метод pop
	//
	//метод size
	//
	//метод swap
	// 
	//метод top дозволяє подивитись найперший елемент в черзі з пріоритетом (якщо перед. по силці, то і змінити)
	//метод top щось типу аналога метода front в черзі
	//
	//ТАКОГО МЕТОДУ ЯК _Get_container В ЧЕРЗІ З ПРІОРИТЕТОМ НЕМАЄ

	//в STL реалізований такий спосіб роботи черги з пріорітетом (priority_queue), що при додаванні елементів 
	//вони зразу вистроюються в черги і додаються в чергу згідно пріоритету (згідно з пріоритетом),
	//який є у цих елементів
	//приорітет такий: ВІД БІЛЬШОГО ДО МЕНШОГО, тобто контейнер відсортовано від більшого до меншого
	//(якщо елемент більше - він переміщується в початок черги, якщо менше - в кінець)

	cout << endl << "priority_queue :" << endl;
	while (!pq.empty())
	{
		cout << pq.top() << endl;
		pq.pop();
		cout << "elements count " << pq.size() << endl;
	}

	return 0;
}